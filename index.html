<!DOCTYPE html>
<html>
<head>
    <title>Title of the document</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="description" content = "">
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        body, html {
            padding: 0;
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background: #666;
        }
        #myCanvas {
            position: relative;
            top: 50%;
            left: 50%;
            -webkit-transform: translate(-50%, -50%);
            -ms-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);    
            border: solid 1px #000;
            background: #fff;
        }
        #fps {
            position: absolute;
            bottom: 10px;
            left: 50%;
            -webkit-transform: translateX(-50%);
            -ms-transform: translateX(-50%);
            transform: translateX(-50%);   
            font-family: sans-serif;
            font-size: 0.8em;
            color: #ddd;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="1000" height="400"></canvas>
    <div id="fps"></div>
    <script>
    var FpsShow = function () {
        this.lastLoop = 0;
        this.thisLoop = 0;
        this.fps = 0;
    };

    FpsShow.prototype.render = function () {
        this.thisLoop = (new Date()).getTime();
        this.fps = 1000 / (this.thisLoop - this.lastLoop);
        this.lastLoop = this.thisLoop;
        document.getElementById('fps').innerHTML = "FPS: " + Math.round(this.fps);
    };

    var Canvas = function () {
        this.canvas = document.getElementById('myCanvas');
        this.context = this.canvas.getContext('2d');
    };

    Canvas.prototype.clean = function () {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    var Keyboard = function () {
        this.keyMap = { 37: false, 38: false, 39: false, 40: false, 32: false, 17: false };
        this.keyMapMemLR = { 37: false, 39: false };
    };

    Keyboard.prototype.kDown = function (e) {
        this.keyMap[e.keyCode] = true;
        this.saveToMem(); // to decide which direction to fire    
    };

    Keyboard.prototype.kUp = function (e) {
        this.keyMap[e.keyCode] = false;
        this.saveToMem(); // to decide which direction to fire
    };

    Keyboard.prototype.saveToMem = function () { // save history of lefr / right key 
        if (this.keyMap[37] == true) {
            this.keyMapMemLR[37] = true;
            this.keyMapMemLR[39] = false;
        }
        if (this.keyMap[39] == true) {
            this.keyMapMemLR[37] = false;
            this.keyMapMemLR[39] = true;
        }
    };

    var Animal = function (canvas, allWeapons, barrier) {
        this.canvas = canvas.canvas;
        this.context = canvas.context;
        this.width = 20;
        this.height = 20;
        this.x = 10; // start position x
        this.y = this.canvas.height - this.height; // start position y
        this.fpsTiming = (new Date()).getTime();
        this.speed = 100; // speed (px / s)
        this.jumpSpeed = 500;
        this.weapons = allWeapons;
        this.barrier = barrier;
        this.jumping = false; // false - not in jump | true - in jump
        this.jumpInic = false;
        this.jumpStartTime = 0; // jump timing - for gravity to calculate actual speed of the jump
        this.falling = false;
        this.fallStartTime = 0;
        this.fallInic = false;
    };

    Animal.prototype.calculateSpeed = function () { // left / right moving (px / s | respecting fps )
        var time = 0, pixels = 0;

        time = (new Date()).getTime() - this.fpsTiming; // timing begin
        pixels = Math.round(this.speed * time / 1000);
        return pixels;
    };

    Animal.prototype.jump = function () {
        var pixels = 0, spd = 0, time = 0;

        if (this.jumping == false && this.jumpInic == false) { // no jumping / no jump initialization
            return;
        }

        if (this.jumpInic == true && this.jumping == false) { // no jumping / jump inic
            this.jumping = true;
            this.jumpStartTime = (new Date()).getTime();
        }

        if (this.jumping == true) { // calculate jump speed
            spd = this.jumpSpeed - (((new Date()).getTime() - this.jumpStartTime) * 1.81); // (jumpspeed) - ((now) - (jump start)) * gravity acceleration

            time = (new Date()).getTime() - this.fpsTiming;
            pixels = Math.round(spd * time / 1000);  

            if (!this.barrier.collision(this.x, this.y - pixels, this.width, this.height)) {
                this.y -= pixels;
            } else {
                this.jumping = false;
                this.y -= this.barrier.newPxMove(this.x, this.y, this.width, this.height, pixels, 'down');
            }
        }
        this.jumpInic = false;
    };

    Animal.prototype.fall = function () {
        
        if (this.jumping == true) {
            return;
        }

        if (this.falling == false && this.fallInic == false) { // test ground
            var test = this.barrier.collision(this.x, this.y + 1, this.width, this.height);
            if (!test) {
                this.fallInic = true;
            }
        }
        
        if (this.falling == false && this.fallInic == true) {
            this.falling = true;
            this.fallStartTime = (new Date()).getTime();
        }

        if (this.falling == true) {
            spd = 0 - (((new Date()).getTime() - this.fallStartTime) * 1.81);

            time = (new Date()).getTime() - this.fpsTiming;
            pixels = Math.round(spd * time / 1000);  

            if (!this.barrier.collision(this.x, this.y - pixels, this.width, this.height)) {
                this.y -= pixels;
            } else {
                this.falling = false;
                this.y -= this.barrier.newPxMove(this.x, this.y, this.width, this.height, pixels, 'down');
            }
            this.fallInic = false;
        }
    };

    Animal.prototype.render = function (keyMap, keyMapMemLR) {
        var left = keyMap[37];
        var up = keyMap[38] || keyMap[32];
        var right = keyMap[39];
        var down = keyMap[40];

        var pixels = this.calculateSpeed(); // move left right

        if (left) {
            if (!this.barrier.collision(this.x - pixels, this.y, this.width, this.height)) {
                this.x -= pixels;
            } else {
                this.x -= this.barrier.newPxMove(this.x, this.y, this.width, this.height, pixels, 'left');
            }
        }
        if (right) {
            if (!this.barrier.collision(this.x + pixels, this.y, this.width, this.height)) {
                this.x += pixels;
            } else {
                this.x += this.barrier.newPxMove(this.x, this.y, this.width, this.height, pixels, 'right');
            }
        }
        if (up) {
            this.jumpInic = true;
        }
            
        this.jump();
        this.fall();

        if (keyMap[17] == true) { // create new weapon
            this.weapons.create(this.x, this.y, this.width, this.height, keyMapMemLR);
        }

        this.context.beginPath();
        this.context.rect(this.x, this.y, this.width, this.height);
        this.context.fillStyle = 'yellow';
        this.context.fill();
        this.context.lineWidth = 2;
        this.context.strokeStyle = 'black';
        this.context.stroke();

        this.fpsTiming = (new Date()).getTime();
    };

    var Barrier = function (canvas) {
        this.allObjects = new Array();
        this.canvas = canvas.canvas;
        this.context = canvas.context;
    };

    Barrier.prototype.add = function (obj) {
        this.allObjects[this.allObjects.length] = obj;
    };

    Barrier.prototype.collision = function (a_x, a_y, a_w, a_h) {
        var ret = false;

        if (a_x < 0 || a_y < 0 || a_x > this.canvas.width  - a_w || a_y > this.canvas.height - a_h) 
            ret = true;            

        this.allObjects.forEach( function (e) {
            if (a_x < e.x + e.width && a_x + a_w > e.x && a_y < e.y + e.height && a_y + a_h > e.y) {
                ret = true;
            }
        });

        return ret;
    };

    Barrier.prototype.newPxMove = function (a_x, a_y, a_w, a_h, pixels, direction) {
        var newPx = 0;

        if (direction == 'down') {
            newPx = 0 - (this.canvas.height - a_y - a_h); // canvas bottom barrier
            a_yt = a_y - pixels;
            this.allObjects.forEach( function (e) {
                if (a_x < e.x + e.width && a_x + a_w > e.x && a_yt < e.y + e.height && a_yt + a_h > e.y) {
                    newPx = 0 - (e.y - a_y - a_h);
                }
            });
        }

        if (direction == 'right') {
            newPx = this.canvas.width - a_x - a_w; // canvas right barrier
            a_xt = a_x + pixels;
            this.allObjects.forEach( function (e) {
                if (a_xt < e.x + e.width && a_xt + a_w > e.x && a_y < e.y + e.height && a_y + a_h > e.y) {
                    newPx = e.x - a_x - a_w;
                }
            });
        }

        if (direction == 'left') {
            newPx = 0; // canvas left barrier
            a_xt = a_x - pixels;
            this.allObjects.forEach( function (e) {
                if (a_xt < e.x + e.width && a_xt + a_w > e.x && a_y < e.y + e.height && a_y + a_h > e.y) {
                    newPx = a_x - e.x - e.width;
                }
            });
        }

        return newPx;
    };

    var Weapon = function (canvas, x, y, right_left, barrier) {
        this.canvas = canvas.canvas;
        this.context = canvas.context;
        this.fpsTiming = (new Date()).getTime();
        this.speed = 400; // px / s
        this.x = x;
        this.y = y;
        this.width = 2;
        this.height = 2;
        this.deleteMe = false;
        this.fire_right_left = right_left; 
        this.barrier = barrier;
    };

    Weapon.prototype.render = function () {
        if (this.fire_right_left == 1)
            this.fireLeft();
        else
            this.fireRight();

        this.context.beginPath();
        this.context.moveTo(this.x, this.y);
        this.context.lineTo(this.x + this.width, this.y);
        this.context.lineWidth = this.height;
        this.context.strokeStyle = '#990000';
        this.context.stroke();

        this.fpsTiming = (new Date()).getTime();
    };

    Weapon.prototype.fireLeft = function () {
        var pixels = this.calculateSpeed();
        this.x -= pixels;
        if (this.barrier.collision(this.x, this.y, this.width, this.height)) {
            this.deleteMe = true;
        }
    };

    Weapon.prototype.fireRight = function () {
        var pixels = this.calculateSpeed();
        this.x += pixels;
        if (this.barrier.collision(this.x, this.y, this.width, this.height)) {
            this.deleteMe = true;
        }
    }

    Weapon.prototype.calculateSpeed = function () {
        var time = 0, pixels = 0;
        time = (new Date()).getTime() - this.fpsTiming;
        pixels = Math.round(this.speed * time / 1000);
        return pixels;
    };

    var AllWeapons = function (canvas, barrier) {
        this.canvas = canvas;
        this.weapons = new Array();
        this.barrier = barrier;
    };

    AllWeapons.prototype.create = function (x, y, width, height, keyMapMemLR) {
        var w_x, w_y, right_left;
        if (keyMapMemLR[37] == true) { // fire to left
            w_x = x - 2;
            w_y = y + (height / 2) - 1; // -1 px (height of the fire)
            right_left = 1;
        } else { // fire to right
            w_x = x + width;
            w_y = y + (height / 2) - 1; // -1 px (height of the fire)
            right_left = 2;
        }

        var w = new Weapon(this.canvas, w_x, w_y, right_left, this.barrier);
        this.weapons[this.weapons.length] = w;
    };

    AllWeapons.prototype.render = function () {
        this.weapons.forEach( function (e, index) {
            e.render();
            if (e.deleteMe == true) {
                delete this.weapons[index];
            }
        }, this);
    };

    var Box = function (canvas, width, height, x, y) {
        this.canvas = canvas.canvas;
        this.context = canvas.context;
        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;
    };

    Box.prototype.render = function () {
        this.context.beginPath();
        this.context.rect(this.x, this.y, this.width, this.height);
        this.context.fillStyle = 'brown';
        this.context.fill();
    };

    var Robot = function (canvas, barrier, x) {
        this.width = 20;
        this.height = 20;
        this.canvas = canvas.canvas;
        this.context = canvas.context;
        this.fpsTiming = (new Date()).getTime();
        this.speed = 50; // speed (px / s)
        this.x = x; // start position x
        this.y = 0; // this.canvas.height - this.height; // start position y
        this.barrier = barrier;
        this.falling = false;
        this.fallStartTime = 0;
        this.fallInic = true;
        this.direction = true; // true - left | false - right
    };

    Robot.prototype.calculateSpeed = function () { // left / right moving (px / s | respecting fps )
        var time = 0, pixels = 0;

        time = (new Date()).getTime() - this.fpsTiming; // timing begin
        pixels = Math.round(this.speed * time / 1000);
        return pixels;
    };

    Robot.prototype.fall = function () {
        if (this.falling == false && this.fallInic == false) { // test ground
            var test = this.barrier.collision(this.x, this.y + 1, this.width, this.height);
            if (!test) {
                this.fallInic = true;
            }
        }
        
        if (this.falling == false && this.fallInic == true) {
            this.falling = true;
            this.fallStartTime = (new Date()).getTime();
        }

        if (this.falling == true) {
            spd = 0 - (((new Date()).getTime() - this.fallStartTime) * 1.81);

            time = (new Date()).getTime() - this.fpsTiming;
            pixels = Math.round(spd * time / 1000);  

            if (!this.barrier.collision(this.x, this.y - pixels, this.width, this.height)) {
                this.y -= pixels;
            } else {
                this.falling = false;
                this.y -= this.barrier.newPxMove(this.x, this.y, this.width, this.height, pixels, 'down');
            }
            this.fallInic = false;
        }
    };

    Robot.prototype.render = function () {

        var pixels = this.calculateSpeed(); // move left right

        if (this.direction) {
            if (!this.barrier.collision(this.x - pixels, this.y, this.width, this.height)) {
                this.x -= pixels;
            } else {
                this.x -= this.barrier.newPxMove(this.x, this.y, this.width, this.height, pixels, 'left');
                this.direction = false;
            }
        }
        else {
            if (!this.barrier.collision(this.x + pixels, this.y, this.width, this.height)) {
                this.x += pixels;
            } else {
                this.x += this.barrier.newPxMove(this.x, this.y, this.width, this.height, pixels, 'right');
                this.direction = true;
            }
        }

        this.fall();

        this.context.beginPath();
        this.context.rect(this.x, this.y, this.width, this.height);
        this.context.fillStyle = 'orange';
        this.context.fill();
        this.context.lineWidth = 2;
        this.context.strokeStyle = 'red';
        this.context.stroke();
        this.fpsTiming = (new Date()).getTime();
    };


    /***** BEGIN INITIALIZATION ********/

    var canvas = new Canvas();
    var fpsShow = new FpsShow();
    var keyboard = new Keyboard();

    document.addEventListener("keydown", function (e) { keyboard.kDown(e); });
    document.addEventListener("keyup", function (e) { keyboard.kUp(e); });

    var box  = new Box(canvas, 300, 20, 100, 380);
    var box2 = new Box(canvas, 200, 100, 550, 300);
    var box3 = new Box(canvas, 100, 50, 780, 350);
    var box4 = new Box(canvas, 50, 50, 470, 350);
    var box5 = new Box(canvas, 10, 20, 570, 280);
    var box6 = new Box(canvas, 10, 20, 740, 280);
    var box7 = new Box(canvas, 10, 80, 760, 320);
    
    var barrier = new Barrier(canvas);
    barrier.add(box);
    barrier.add(box2);
    barrier.add(box3);
    barrier.add(box4);
    barrier.add(box5);
    barrier.add(box6);
    barrier.add(box7);

    var allWeapons = new AllWeapons(canvas, barrier);
    var animal = new Animal(canvas, allWeapons, barrier);
    var robot = new Robot(canvas, barrier, 950);
    var robot2 = new Robot(canvas, barrier, 750);
    var robot3 = new Robot(canvas, barrier, 550);
    var robot4 = new Robot(canvas, barrier, 350);
    
    setInterval( function () {
        fpsShow.render();
        canvas.clean();
        animal.render(keyboard.keyMap, keyboard.keyMapMemLR);
        robot.render();
        robot2.render();
        robot3.render();
        robot4.render();
        allWeapons.render();
        box.render();
        box2.render();
        box3.render();
        box4.render();
        box5.render();
        box6.render();
        box7.render();
    }, 1000 / 60);

    </script>
</body>
</html>
